#version 450

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"

// Workgroup size: 256 threads per workgroup
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input: all leaf instances from TreeSystem (tree-local space)
layout(std430, binding = BINDING_TREE_LEAF_CULL_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: visible leaf instances after culling (WORLD space with tree index)
layout(std430, binding = BINDING_TREE_LEAF_CULL_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// Single indirect draw command for ALL visible leaves
// Uses DrawIndexedIndirectCommand for vkCmdDrawIndexedIndirect
layout(std430, binding = BINDING_TREE_LEAF_CULL_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmd;
};

// Per-tree culling data (batched for all trees)
struct TreeCullData {
    mat4 treeModel;                // Tree's model matrix
    uint inputFirstInstance;       // Offset into inputInstances for this tree
    uint inputInstanceCount;       // Number of input instances for this tree
    uint treeIndex;                // Index of this tree (for render data lookup)
    uint _pad;
};

layout(std430, binding = BINDING_TREE_LEAF_CULL_TREES) readonly buffer TreeDataBuffer {
    TreeCullData treeData[];
};

// Global culling uniforms (shared across all trees)
layout(binding = BINDING_TREE_LEAF_CULL_UNIFORMS) uniform TreeLeafCullUniforms {
    vec4 cameraPosition;          // xyz = camera pos, w = unused
    vec4 frustumPlanes[6];        // Frustum planes for culling
    float maxDrawDistance;        // Maximum leaf draw distance
    float lodTransitionStart;     // LOD transition start distance
    float lodTransitionEnd;       // LOD transition end distance
    float maxLodDropRate;         // Maximum LOD drop rate (0.0-1.0)
    uint numTrees;                // Total number of trees
    uint totalLeafInstances;      // Total leaf instances across all trees
    uint _pad0;
    uint _pad1;
};

void main() {
    uint globalIdx = gl_GlobalInvocationID.x;

    // First thread initializes the indirect command (constant values)
    if (globalIdx == 0) {
        drawCmd.indexCount = 6;       // Quad: 6 indices
        drawCmd.firstIndex = 0;
        drawCmd.vertexOffset = 0;
        drawCmd.firstInstance = 0;
        // instanceCount is set via atomicAdd below
    }

    // Early exit if beyond total leaf count
    if (globalIdx >= totalLeafInstances) {
        return;
    }

    // Find which tree this leaf belongs to using binary search
    // Since we know input ranges are contiguous, we can search for the tree
    uint treeIdx = 0;
    uint low = 0;
    uint high = numTrees;

    while (low < high) {
        uint mid = (low + high) / 2;
        uint treeStart = treeData[mid].inputFirstInstance;
        uint treeEnd = treeStart + treeData[mid].inputInstanceCount;

        if (globalIdx < treeStart) {
            high = mid;
        } else if (globalIdx >= treeEnd) {
            low = mid + 1;
        } else {
            treeIdx = mid;
            break;
        }
    }

    // Get tree data
    TreeCullData tree = treeData[treeIdx];

    // Local index within this tree's leaf instances
    uint localIdx = globalIdx - tree.inputFirstInstance;

    // Sanity check
    if (localIdx >= tree.inputInstanceCount) {
        return;
    }

    // Get input instance
    LeafInstance leaf = inputInstances[globalIdx];

    // Transform leaf position to world space
    vec3 leafLocalPos = leaf.positionAndSize.xyz;
    vec4 worldPos = tree.treeModel * vec4(leafLocalPos, 1.0);

    // Distance culling
    float distToCamera = getDistanceToCamera(worldPos.xyz, cameraPosition.xyz);
    if (distToCamera > maxDrawDistance) {
        return;
    }

    // Frustum culling with margin for leaf size
    float leafSize = leaf.positionAndSize.w;
    float margin = leafSize * 2.0;  // Extra margin for leaf billboard rotation
    if (!isInFrustum(frustumPlanes, worldPos.xyz, margin)) {
        return;
    }

    // LOD blade dropping - use position-based hash for consistent results
    float instanceHash = hash2D(leafLocalPos.xz);
    if (lodCull(distToCamera, lodTransitionStart, lodTransitionEnd,
                maxLodDropRate, instanceHash)) {
        return;
    }

    // This leaf is visible - atomically get output slot (SINGLE global counter)
    uint outputSlot = atomicAdd(drawCmd.instanceCount, 1);

    // Transform orientation to world space
    // Extract rotation from model matrix and combine with local orientation
    mat3 rotationMatrix = mat3(tree.treeModel);
    vec4 treeRotQuat = mat3ToQuat(rotationMatrix);
    vec4 worldOrientation = quatMul(treeRotQuat, leaf.orientation);

    // Write world-space leaf with tree index
    outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
    outputInstances[outputSlot].worldOrientation = worldOrientation;
    outputInstances[outputSlot].treeIndex = tree.treeIndex;
    outputInstances[outputSlot]._pad0 = 0;
    outputInstances[outputSlot]._pad1 = 0;
    outputInstances[outputSlot]._pad2 = 0;
}
