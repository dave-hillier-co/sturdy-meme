#version 450

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"

// Workgroup size: 256 threads per workgroup
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input: all leaf instances from TreeSystem
layout(std430, binding = BINDING_TREE_LEAF_CULL_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: visible leaf instances after culling
layout(std430, binding = BINDING_TREE_LEAF_CULL_OUTPUT) writeonly buffer OutputBuffer {
    LeafInstance outputInstances[];
};

// Indirect draw commands for instanced rendering (one per tree)
// Uses DrawIndexedIndirectCommand for vkCmdDrawIndexedIndirect
layout(std430, binding = BINDING_TREE_LEAF_CULL_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[];
};

// Per-tree culling data (batched for all trees)
struct TreeCullData {
    mat4 treeModel;                // Tree's model matrix
    uint inputFirstInstance;       // Offset into inputInstances for this tree
    uint inputInstanceCount;       // Number of input instances for this tree
    uint outputBaseOffset;         // Base offset in output buffer for this tree
    uint treeIndex;                // Index of this tree (for indirect command array)
};

layout(std430, binding = BINDING_TREE_LEAF_CULL_TREES) readonly buffer TreeDataBuffer {
    TreeCullData treeData[];
};

// Global culling uniforms (shared across all trees)
layout(binding = BINDING_TREE_LEAF_CULL_UNIFORMS) uniform TreeLeafCullUniforms {
    vec4 cameraPosition;          // xyz = camera pos, w = unused
    vec4 frustumPlanes[6];        // Frustum planes for culling
    float maxDrawDistance;        // Maximum leaf draw distance
    float lodTransitionStart;     // LOD transition start distance (density starts reducing)
    float lodTransitionEnd;       // LOD transition end distance (max drop rate reached)
    float maxLodDropRate;         // Maximum LOD drop rate (0.0-1.0)
    uint numTrees;                // Total number of trees
    uint totalLeafInstances;      // Total leaf instances across all trees
    uint _pad0;
    uint _pad1;
};

// Improved continuous density curve (AAA-style)
// Returns probability of keeping a leaf based on distance
// Uses smooth hermite curve for natural falloff
float calculateLeafDensity(float distance, float nearStart, float farEnd, float maxDropRate) {
    // Three-phase density curve:
    // 1. Full density at close range (0 to nearStart * 0.5)
    // 2. Gradual reduction (nearStart * 0.5 to nearStart)
    // 3. Aggressive reduction (nearStart to farEnd)

    float earlyStart = nearStart * 0.33;  // Start reducing at 1/3 of lodTransitionStart

    if (distance < earlyStart) {
        return 1.0;  // Full density very close
    }

    // Use smoothstep for natural-looking falloff
    float t;
    if (distance < nearStart) {
        // Early phase: gentle reduction (keep 100% to 85%)
        t = smoothstep(earlyStart, nearStart, distance);
        return mix(1.0, 0.85, t);
    } else {
        // Main phase: aggressive reduction (85% to (1 - maxDropRate))
        t = smoothstep(nearStart, farEnd, distance);
        // Apply exponential curve for more aggressive distant culling
        t = t * t;  // Quadratic for steeper falloff
        return mix(0.85, 1.0 - maxDropRate, t);
    }
}

// Improved LOD cull that uses continuous density curve
bool continuousLodCull(float distance, float nearStart, float farEnd,
                       float maxDropRate, float instanceHash) {
    float keepProbability = calculateLeafDensity(distance, nearStart, farEnd, maxDropRate);
    return instanceHash > keepProbability;  // Cull if hash exceeds keep probability
}

void main() {
    uint globalIdx = gl_GlobalInvocationID.x;

    // Early exit if beyond total leaf count
    if (globalIdx >= totalLeafInstances) {
        return;
    }

    // Find which tree this leaf belongs to using binary search
    // Since we know input ranges are contiguous, we can search for the tree
    uint treeIdx = 0;
    uint low = 0;
    uint high = numTrees;

    while (low < high) {
        uint mid = (low + high) / 2;
        uint treeStart = treeData[mid].inputFirstInstance;
        uint treeEnd = treeStart + treeData[mid].inputInstanceCount;

        if (globalIdx < treeStart) {
            high = mid;
        } else if (globalIdx >= treeEnd) {
            low = mid + 1;
        } else {
            treeIdx = mid;
            break;
        }
    }

    // Get tree data
    TreeCullData tree = treeData[treeIdx];

    // Local index within this tree's leaf instances
    uint localIdx = globalIdx - tree.inputFirstInstance;

    // Sanity check
    if (localIdx >= tree.inputInstanceCount) {
        return;
    }

    // Get input instance
    LeafInstance leaf = inputInstances[globalIdx];

    // Transform leaf position to world space
    vec3 leafLocalPos = leaf.positionAndSize.xyz;
    vec4 worldPos = tree.treeModel * vec4(leafLocalPos, 1.0);

    // Distance culling
    float distToCamera = getDistanceToCamera(worldPos.xyz, cameraPosition.xyz);
    if (distToCamera > maxDrawDistance) {
        return;
    }

    // Frustum culling with margin for leaf size
    float leafSize = leaf.positionAndSize.w;
    float margin = leafSize * 2.0;  // Extra margin for leaf billboard rotation
    if (!isInFrustum(frustumPlanes, worldPos.xyz, margin)) {
        return;
    }

    // Continuous leaf density reduction - use position-based hash for consistent results
    float instanceHash = hash2D(leafLocalPos.xz);
    if (continuousLodCull(distToCamera, lodTransitionStart, lodTransitionEnd,
                          maxLodDropRate, instanceHash)) {
        return;
    }

    // This leaf is visible - atomically get output slot for this tree
    uint outputSlot = atomicAdd(drawCmds[tree.treeIndex].instanceCount, 1);

    // Write to output buffer at the allocated slot
    // Output position remains in tree-local space (shader applies model matrix)
    outputInstances[tree.outputBaseOffset + outputSlot] = leaf;
}
