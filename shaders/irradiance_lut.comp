#version 450

#extension GL_GOOGLE_include_directive : require

#include "atmosphere_common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, rgba16f) writeonly uniform image2D rayleighIrradianceLUT;
layout(binding = 1, rgba16f) writeonly uniform image2D mieIrradianceLUT;
layout(binding = 2) uniform sampler2D transmittanceLUT;

layout(binding = 3) uniform AtmosphereUniforms {
    AtmosphereParams params;
    vec4 sunDirection;
    vec4 cameraPosition;
    float padding[2];
} uAtmosphere;

const int MARCH_STEPS = 32;
const int SAMPLE_COUNT = 32;

vec3 sampleTransmittance(float r, float mu) {
    vec2 uv = TransmittanceLUTParamsToUV(r, mu, uAtmosphere.params);
    return texture(transmittanceLUT, uv).rgb;
}

struct ScatteringComponents {
    vec3 rayleigh;
    vec3 mie;
};

// Compute un-phased scattering along a view ray toward the sky dome
ScatteringComponents integrateUnweightedScattering(float altitude, vec3 viewDir, float cosSunZenith) {
    float r = uAtmosphere.params.planetRadius + altitude;
    vec3 pos = vec3(0.0, r, 0.0);
    vec3 sunDir = vec3(sqrt(1.0 - cosSunZenith * cosSunZenith), cosSunZenith, 0.0);

    float rayLength = DistanceToAtmosphereBoundary(r, dot(viewDir, normalize(pos)), uAtmosphere.params.atmosphereRadius);
    float stepSize = rayLength / float(MARCH_STEPS);

    ScatteringComponents result;
    result.rayleigh = vec3(0.0);
    result.mie = vec3(0.0);

    for (int i = 0; i < MARCH_STEPS; i++) {
        float t = (float(i) + 0.5) * stepSize;
        vec3 samplePos = pos + viewDir * t;
        float sampleR = length(samplePos);
        float sampleAlt = sampleR - uAtmosphere.params.planetRadius;

        vec3 density = GetAtmosphereDensity(sampleAlt, uAtmosphere.params);

        float muS = dot(normalize(samplePos), sunDir);
        vec3 transmittanceToSun = sampleTransmittance(sampleR, muS);

        float muView = dot(normalize(pos), viewDir);
        vec3 transmittanceToView = sampleTransmittance(r, muView);

        vec3 rayleighScatter = density.x * uAtmosphere.params.rayleighScatteringBase;
        vec3 mieScatter = vec3(density.y * uAtmosphere.params.mieScatteringBase);

        vec3 attenuation = transmittanceToSun * transmittanceToView * stepSize;

        result.rayleigh += rayleighScatter * attenuation;
        result.mie += mieScatter * attenuation;
    }

    return result;
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(rayleighIrradianceLUT);

    if (texel.x >= size.x || texel.y >= size.y) {
        return;
    }

    vec2 uv = (vec2(texel) + 0.5) / vec2(size);
    float cosSunZenith = uv.x * 2.0 - 1.0;
    float altitude = uv.y * (uAtmosphere.params.atmosphereRadius - uAtmosphere.params.planetRadius);

    vec3 normal = vec3(0.0, 1.0, 0.0);

    vec3 rayleighIrradiance = vec3(0.0);
    vec3 mieIrradiance = vec3(0.0);

    for (int i = 0; i < SAMPLE_COUNT; i++) {
        vec2 xi = Hammersley(uint(i), uint(SAMPLE_COUNT));
        vec3 dir = UniformHemisphere(xi);

        ScatteringComponents scatter = integrateUnweightedScattering(altitude, dir, cosSunZenith);
        float lambert = max(0.0, dot(normal, dir));
        float weight = lambert * (2.0 * PI / float(SAMPLE_COUNT));

        rayleighIrradiance += scatter.rayleigh * weight;
        mieIrradiance += scatter.mie * weight;
    }

    imageStore(rayleighIrradianceLUT, texel, vec4(rayleighIrradiance, 1.0));
    imageStore(mieIrradianceLUT, texel, vec4(mieIrradiance, 1.0));
}
