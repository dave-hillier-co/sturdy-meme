#version 450

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "instancing_common.glsl"

// Workgroup size: 256 threads per workgroup
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input: All trees in the scene (uploaded once when trees change)
struct TreeInputData {
    vec4 positionAndScale;    // xyz = world position, w = scale
    vec4 rotationAndArchetype; // x = Y-axis rotation, yzw = archetype index as uint bits
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_INPUT) readonly buffer InputBuffer {
    TreeInputData trees[];
};

// Output: Visible impostor instances (GPU-generated each frame)
struct ImpostorOutputData {
    vec4 positionAndScale;     // xyz = world position, w = scale
    vec4 rotationAndArchetype; // x = rotation, y = archetype, z = blend factor, w = reserved
    vec4 sizeAndOffset;        // x = hSize, y = vSize, z = baseOffset, w = reserved
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_OUTPUT) writeonly buffer OutputBuffer {
    ImpostorOutputData visibleImpostors[];
};

// Single indirect draw command for ALL visible impostors
layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmd;
};

// Culling uniforms
layout(binding = BINDING_TREE_IMPOSTOR_CULL_UNIFORMS) uniform ImpostorCullUniforms {
    vec4 cameraPosition;           // xyz = camera pos, w = unused
    vec4 frustumPlanes[6];         // Frustum planes for culling
    mat4 viewProjMatrix;           // View-projection matrix for Hi-Z testing
    vec4 screenParams;             // x = width, y = height, z = 1/width, w = 1/height
    float fullDetailDistance;      // Trees closer than this render as geometry
    float impostorDistance;        // Trees beyond this are culled
    float hysteresis;              // Hysteresis for LOD transitions
    float blendRange;              // Distance over which to blend LODs
    uint numTrees;                 // Total number of trees
    uint enableHiZ;                // 1 = enable Hi-Z culling, 0 = frustum only
    uint useScreenSpaceError;      // 1 = use screen-space error LOD, 0 = distance-based
    float tanHalfFOV;              // tan(fov/2) for screen-space error calculation
    float errorThresholdFull;      // Screen error threshold for full detail (pixels)
    float errorThresholdImpostor;  // Screen error threshold for impostor (pixels)
    float errorThresholdCull;      // Screen error beyond which to cull
    uint _pad0;
};

// Hi-Z pyramid for occlusion culling
layout(binding = BINDING_TREE_IMPOSTOR_CULL_HIZ) uniform sampler2D hiZPyramid;

// Per-archetype sizing data
struct ArchetypeData {
    vec4 sizingData;   // x = hSize, y = vSize, z = baseOffset, w = boundingSphereRadius
    vec4 lodErrorData; // x = worldErrorFull, y = worldErrorImpostor, z = unused, w = unused
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_ARCHETYPE) readonly buffer ArchetypeBuffer {
    ArchetypeData archetypes[];
};

// Compute screen-space error from world-space error
// Formula: screenError = worldError * screenHeight / (2 * distance * tan(fov/2))
float computeScreenError(float worldError, float distance) {
    if (distance <= 0.0) return 9999.0; // Infinite error at zero distance
    return worldError * screenParams.y / (2.0 * distance * tanHalfFOV);
}

// Hi-Z occlusion test
// Returns true if the object is occluded (not visible)
bool isOccludedHiZ(vec3 worldPos, float boundingRadius) {
    // Project tree center to clip space
    vec4 clipPos = viewProjMatrix * vec4(worldPos, 1.0);

    // Skip if behind camera
    if (clipPos.w <= 0.0) {
        return true;  // Behind camera, treat as occluded
    }

    // Convert to NDC
    vec3 ndc = clipPos.xyz / clipPos.w;

    // Skip if outside NDC range (should be caught by frustum culling, but double check)
    if (abs(ndc.x) > 1.0 || abs(ndc.y) > 1.0 || ndc.z < 0.0 || ndc.z > 1.0) {
        return false;  // Outside screen, let frustum culling handle it
    }

    // Convert to UV coordinates [0,1]
    vec2 screenUV = ndc.xy * 0.5 + 0.5;

    // Calculate screen-space radius for mip level selection
    // Project a point offset by boundingRadius to estimate screen coverage
    float screenRadius = boundingRadius / clipPos.w * screenParams.x * 0.5;

    // Choose mip level based on screen-space size
    // Use a conservative (higher) mip level to avoid false culling
    float mipLevel = max(0.0, log2(max(screenRadius * 2.0, 1.0)));

    // Clamp to valid mip range (assume max 12 levels for 4K)
    mipLevel = min(mipLevel, 11.0);

    // Sample Hi-Z at appropriate mip (returns MIN depth in the region)
    // Hi-Z uses reversed-Z: 0 = far, 1 = near
    // Min = farthest visible point in the region
    float occluderDepth = textureLod(hiZPyramid, screenUV, mipLevel).r;

    // Calculate conservative depth for tree (use back of bounding sphere - farthest point)
    // In reversed-Z, we want the farthest point of the tree to compare against
    // the farthest visible occluder point
    vec3 toCamera = normalize(cameraPosition.xyz - worldPos);
    vec3 farthestPoint = worldPos - toCamera * boundingRadius;  // Point away from camera
    vec4 farthestClip = viewProjMatrix * vec4(farthestPoint, 1.0);
    float treeDepth = farthestClip.z / farthestClip.w;

    // Tree is occluded if its farthest point is farther than the farthest visible occluder
    // In reversed-Z: smaller depth = farther
    // Add small margin to account for precision issues
    float depthMargin = 0.001;
    return treeDepth < occluderDepth - depthMargin;
}

void main() {
    uint treeIdx = gl_GlobalInvocationID.x;

    // First thread initializes the indirect command (constant values)
    if (treeIdx == 0) {
        drawCmd.indexCount = 6;       // Billboard quad: 6 indices
        drawCmd.firstIndex = 0;
        drawCmd.vertexOffset = 0;
        drawCmd.firstInstance = 0;
        // instanceCount is set via atomicAdd below
    }

    // Early exit if beyond tree count
    if (treeIdx >= numTrees) {
        return;
    }

    // Load tree data
    TreeInputData tree = trees[treeIdx];
    vec3 treePos = tree.positionAndScale.xyz;
    float treeScale = tree.positionAndScale.w;
    float rotation = tree.rotationAndArchetype.x;
    uint archetypeIndex = floatBitsToUint(tree.rotationAndArchetype.y);

    // Distance to camera
    float distToCamera = getDistanceToCamera(treePos, cameraPosition.xyz);

    // Get archetype sizing data
    ArchetypeData arch = archetypes[archetypeIndex];
    float boundingRadius = arch.sizingData.w * treeScale;
    float vSize = arch.sizingData.y * treeScale;  // Vertical half-size

    // LOD selection - either screen-space error or distance-based
    bool shouldRenderAsImpostor = false;
    bool shouldCull = false;

    if (useScreenSpaceError != 0u) {
        // Screen-space error LOD (Phase 4)
        // Scale world error by tree scale (larger trees have proportionally larger errors)
        float worldErrorFull = arch.lodErrorData.x * treeScale;
        float worldErrorImpostor = arch.lodErrorData.y * treeScale;

        float screenErrorFull = computeScreenError(worldErrorFull, distToCamera);
        float screenErrorImpostor = computeScreenError(worldErrorImpostor, distToCamera);

        // Tree should render as full geometry if full detail error is acceptable
        // It should render as impostor if impostor error is acceptable but full is not
        // It should be culled if even impostor error is too large
        if (screenErrorFull <= errorThresholdFull) {
            // Tree is close enough for full detail - skip impostor
            return;
        } else if (screenErrorImpostor > errorThresholdCull) {
            // Tree is too far even for impostor (sub-pixel)
            shouldCull = true;
        } else {
            // Tree should render as impostor
            shouldRenderAsImpostor = true;
        }
    } else {
        // Legacy distance-based LOD
        // Skip trees too close (they render as full geometry)
        if (distToCamera < fullDetailDistance - hysteresis) {
            return;
        }
        // Skip trees too far
        if (distToCamera > impostorDistance) {
            shouldCull = true;
        } else {
            shouldRenderAsImpostor = true;
        }
    }

    if (shouldCull) {
        return;
    }

    // Calculate tree center (base position + vertical offset)
    // Trees are positioned at their base, but extend upward
    vec3 treeCenter = treePos + vec3(0.0, vSize, 0.0);

    // Frustum culling with margin for billboard size
    float margin = boundingRadius * 2.0;
    if (!isInFrustum(frustumPlanes, treeCenter, margin)) {
        return;
    }

    // Hi-Z occlusion culling (Phase 2: eliminate trees behind terrain/occluders)
    // Use tree center for occlusion test, not base position
    if (enableHiZ != 0u && isOccludedHiZ(treeCenter, boundingRadius)) {
        return;
    }

    // Calculate blend factor for LOD transition
    // 0 = pure geometry, 1 = pure impostor
    float blendFactor = 1.0;
    if (useScreenSpaceError != 0u) {
        // Screen-space error based blending
        // Blend from full geometry to impostor based on screen error thresholds
        float worldErrorFull = arch.lodErrorData.x * treeScale;
        float screenErrorFull = computeScreenError(worldErrorFull, distToCamera);

        // Blend between errorThresholdFull and errorThresholdImpostor
        if (screenErrorFull < errorThresholdFull) {
            blendFactor = 0.0;
        } else if (screenErrorFull > errorThresholdImpostor) {
            blendFactor = 1.0;
        } else {
            blendFactor = smoothstep(errorThresholdFull, errorThresholdImpostor, screenErrorFull);
        }
    } else {
        // Legacy distance-based blending
        if (distToCamera < fullDetailDistance + blendRange) {
            blendFactor = smoothstep(fullDetailDistance - hysteresis,
                                      fullDetailDistance + blendRange,
                                      distToCamera);
        }
    }

    // This impostor is visible - atomically get output slot
    uint outputSlot = atomicAdd(drawCmd.instanceCount, 1);

    // Write visible impostor data
    visibleImpostors[outputSlot].positionAndScale = vec4(treePos, treeScale);
    visibleImpostors[outputSlot].rotationAndArchetype = vec4(
        rotation,
        float(archetypeIndex),
        blendFactor,
        0.0  // reserved
    );
    visibleImpostors[outputSlot].sizeAndOffset = vec4(
        arch.sizingData.x * treeScale,  // hSize pre-scaled
        arch.sizingData.y * treeScale,  // vSize pre-scaled
        arch.sizingData.z * treeScale,  // baseOffset pre-scaled
        0.0  // reserved
    );
}
